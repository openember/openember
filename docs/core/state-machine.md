# OpenEmber 状态机设计规范（OpenEmber State Machine Specification）

> 本文定义 OpenEmber Core 中**状态机（State Machine）\**的设计原则、语义约束与最小能力集合。
> 状态机是 OpenEmber 用于描述设备、模块和系统运行阶段的\**基础抽象**，用于保证长期运行系统的可预测性、安全性与可运维性。



## 1. 设计目标

OpenEmber 状态机的设计目标不是“功能强大”，而是：

- **可预测（Predictable）**：系统在任何时刻都处于一个明确状态
- **可约束（Constrained）**：状态转移路径是有限且可审计的
- **可恢复（Recoverable）**：异常可映射到状态，而不是隐式崩溃
- **可组合（Composable）**：模块状态可组合为系统状态
- **语言无关（Language-agnostic）**：不依赖 C / C++ / OOP 特性



## 2. 核心概念

### 2.1 状态（State）

状态表示一个模块或系统在某一时间点的**运行阶段语义**。

状态必须满足：

- 有**明确名称**
- 表示一个**稳定条件**（而非瞬时行为）
- 可以被**外部观测和记录**

状态不等价于：

- 线程是否运行
- 某个函数是否正在执行
- 某个条件变量是否为真

### 2.2 状态转移（Transition）

状态转移表示从一个状态到另一个状态的**受控变化**。

每一次状态转移必须：

- 由**显式事件**触发
- 具备**可判定的前置条件**
- 具有**明确的目标状态**

隐式或自动跳转（如在构造函数中直接进入运行态）在 Core 中不被推荐。

### 2.3 事件（Event）

事件是触发状态转移的唯一合法原因。

事件可以来源于：

- 外部输入（命令、通信消息）
- 内部条件（初始化完成、错误发生）
- 定时器 / 看门狗

事件本身不携带状态改变语义，**语义由状态机定义**。



## 3. OpenEmber Core 标准状态模型

### 3.1 必选基础状态（Mandatory States）

所有 OpenEmber 模块级状态机 **必须支持** 以下基础状态：

| 状态       | 语义                           |
| ---------- | ------------------------------ |
| `INIT`     | 对象已创建，但尚未具备运行条件 |
| `READY`    | 初始化完成，可被启动           |
| `RUNNING`  | 正常运行中                     |
| `STOPPED`  | 主动停止，但可再次启动         |
| `ERROR`    | 发生错误，功能受限或不可用     |
| `SHUTDOWN` | 不可逆终止状态                 |

### 3.2 状态语义约束

- `INIT → READY` 必须是**显式初始化完成事件**
- `READY → RUNNING` 必须由启动事件触发
- `RUNNING → STOPPED` 必须是可控行为
- `ANY → ERROR` 允许，但必须记录原因
- `ERROR → READY` 仅在错误可恢复时允许
- `SHUTDOWN` 不允许转出



## 4. 错误与状态的关系

### 4.1 错误不是状态的替代

错误（Error）是**状态转移的原因或结果**，而不是状态本身。

原则：

- 错误发生 ⇒ 进入 `ERROR`
- 错误恢复 ⇒ 返回 `READY` 或 `STOPPED`

不允许通过错误码“偷偷改变行为而不改变状态”。

### 4.2 错误分级建议

Core 不强制错误分级，但建议实现区分：

- 可恢复错误（Recoverable）
- 不可恢复错误（Fatal）

不可恢复错误应直接进入 `SHUTDOWN`。



## 5. 模块状态机（Module FSM）

### 5.1 模块状态机定义

每一个 OpenEmber 模块：

- 必须拥有**独立状态机**
- 不得依赖其他模块状态进行隐式跳转

模块之间的协作应通过**事件或消息**完成，而非状态耦合。

### 5.2 状态查询与观测

模块状态必须：

- 可被查询（同步或异步）
- 可被日志系统记录
- 可被上层系统聚合



## 6. 系统级状态组合（System State Aggregation）

系统状态不是一个新的 FSM，而是模块状态的**组合视图**。

示例规则（非强制）：

- 任一关键模块处于 `ERROR` ⇒ 系统为 `DEGRADED`
- 所有模块为 `READY` 或 `RUNNING` ⇒ 系统为 `OPERATIONAL`

Core 仅规定：

> 系统状态 **不得反向驱动** 模块状态。



## 7. 并发与状态一致性

- 同一模块在任一时刻 **只能处于一个状态**
- 状态变更必须是原子的
- 并发事件需有确定的处理顺序

实现可使用：

- 互斥锁
- 原子变量
- 单线程事件循环

Core 不限制具体机制，但要求**结果一致**。



## 8. 生命周期与状态机

对象生命周期必须与状态机保持一致：

- 对象创建 ⇒ `INIT`
- 对象可用 ⇒ `READY`
- 对象销毁前 ⇒ `SHUTDOWN`

禁止“对象已析构但状态仍可被查询”的设计。



## 9. 扩展状态

实现可在 Core 状态基础上扩展子状态，例如：

- `RUNNING:IDLE`
- `RUNNING:BUSY`

扩展状态必须：

- 映射到某一 Core 状态
- 不改变 Core 状态语义



## 10. 合规性要求（Conformance）

一个实现若声称“遵循 OpenEmber Core 状态机规范”，必须：

- 实现所有必选基础状态
- 遵守状态转移约束
- 不引入隐藏状态或隐式转移

违反状态机规范的行为视为 **Core 不兼容实现**。



## 11. 设计哲学（非规范性说明）

OpenEmber 状态机的核心思想是：**状态是系统对外可承诺的行为边界，而不是实现细节。**

它服务于：

- 长期运行系统
- 工程可维护性
- 运维与诊断
- 多实现一致性

------

*End of OpenEmber State Machine Specification (Draft v0.1)*