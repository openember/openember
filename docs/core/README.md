# OpenEmber Core 规范

> 本文档定义 OpenEmber 框架的核心语义规范（Core Specification），用于约束和指导不同实现（如 OpenEmber / OpenEmber‑Plus）。



## 1. 目标与范围

### 1.1 设计目标

OpenEmber Core 的目标不是规定“如何实现”，而是明确：

- 一个 **OpenEmber 系统是什么**
- 系统中各组件 **应该如何协作**
- 不同实现之间 **必须保持一致的行为语义**

Core 关注的是 **概念、语义和约束**，而不是语言、库或具体技术选型。

### 1.2 非目标

OpenEmber Core 不负责：

- 指定编程语言（C / C++ / Rust 等）
- 指定通信库（nanomsg / ZeroMQ / asio 等）
- 指定操作系统或硬件平台
- 提供完整实现代码

## 2. 基本概念

### 2.1 系统（System）

OpenEmber 系统是由一组 **模块（Module）** 组成的运行时集合，由 **运行时（Runtime）** 管理其生命周期和协作关系。

一个系统必须具备：

- 模块注册与发现机制
- 模块生命周期管理
- 模块间通信能力
- 配置、状态与错误的可观测性

## 3. 模块模型（Module Model）

### 3.1 模块定义

模块是 OpenEmber 系统中的基本执行单元，具有以下属性：

- 唯一标识（Module ID）
- 明确的生命周期
- 明确定义的输入 / 输出接口
- 内部状态，但不直接暴露内部实现

模块 **不应假设** 其他模块的存在方式或实现细节。

### 3.2 模块生命周期

每个模块必须遵循统一的生命周期状态机：

```bash
UNINITIALIZED
      |
      v
 INITIALIZED
      |
      v
   STARTED
      |
      v
   STOPPED
```

#### 状态说明

- **UNINITIALIZED**：模块尚未完成初始化
- **INITIALIZED**：资源已分配，但尚未对外提供服务
- **STARTED**：模块处于正常工作状态
- **STOPPED**：模块已停止，不再处理消息

#### 生命周期规则

- 生命周期变迁必须是 **单向、可预测的**
- 不允许从 STARTED 回到 INITIALIZED
- 初始化失败必须进入 STOPPED 或错误状态

## 4. 通信模型（Communication Model）

### 4.1 消息（Message）

模块之间通过 **消息** 进行通信。

每条消息至少包含：

- 消息类型（Type）
- 源模块 ID
- 目标模块 ID（或主题）
- 有效载荷（Payload）

Core **不规定** Payload 的编码格式。

### 4.2 消息语义

OpenEmber Core 只规定最小语义保证：

| 属性     | 语义                           |
| -------- | ------------------------------ |
| 可靠性   | 允许丢失                       |
| 顺序     | 不保证                         |
| 投递方式 | 至少一次或最多一次，由实现决定 |
| 阻塞     | 不要求同步                     |

实现可以提供 **更强语义**，但不得弱于上述约束。

## 5. 配置模型（Configuration Model）

### 5.1 配置原则

- 配置与代码解耦
- 模块只能访问声明过的配置项
- 配置变更必须可被模块感知

### 5.2 生命周期关系

- 配置应在模块 INITIALIZED 前可用
- 运行时配置变更是否支持由实现决定

## 6. 错误模型（Error Model）

### 6.1 错误分类

错误至少分为：

- **可恢复错误**：模块可继续运行
- **不可恢复错误**：模块必须停止

### 6.2 错误传播

- 错误不得被无声吞掉
- 错误必须至少通过日志或状态接口暴露

## 7. 状态与可观测性（Observability）

### 7.1 状态暴露

每个模块必须能够暴露：

- 当前生命周期状态
- 最近一次错误（如有）

### 7.2 健康检查

系统应能判断：

- 模块是否存活
- 模块是否处于 STARTED 状态

## 8. 并发与线程模型假设

OpenEmber Core 不强制并发模型，但要求：

- 模块实现必须是 **线程安全或明确声明非线程安全**
- 不得在 Core 级别假设全局单线程

## 9. 兼容性与演进

### 9.1 向后兼容原则

- Core 的语义变更必须显式声明
- 行为变更优先通过扩展而非破坏实现

### 9.2 实现一致性

不同实现（如 OpenEmber / OpenEmber‑Plus）在 Core 定义的行为上必须保持一致。

## 10. 参考实现

- **OpenEmber**：OpenEmber Core 的标准 C 实现
- **OpenEmber‑Plus**：遵循同一 Core 的 C++ 增强实现

## 11. 结语

OpenEmber Core 的存在，是为了确保：

> 不同语言、不同实现、不同团队， 仍然可以构建出**语义一致、行为可预期**的 OpenEmber 系统。

规范先于实现，约定先于自由。